<!doctype html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=description content="A front-end template that helps you build fast, modern mobile web apps."><meta name=viewport content="width=device-width, initial-scale=1"><title>Polymer 0.8 Primer Summary - Natively/Installable</title><link rel=manifest href=/manifest.json><meta name=mobile-web-app-capable content=yes><link rel=icon sizes=196x196 href=/images/icons/icon-wakr-touched.png><meta name=apple-mobile-web-app-capable content=yes><meta name=apple-mobile-web-app-status-bar-style content=black><meta name=apple-mobile-web-app-title content="Web Starter Kit"><meta name=msapplication-TileImage content=/images/icons/icon-wakr-touched-mswin9.png><meta name=msapplication-TileColor content=#3372DF><link rel=stylesheet href=/styles/components/main.min.css><link href=//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css rel=stylesheet></head><body><header class="app-bar promote-layer"><div class=app-bar-container><button class=menu><img src=/images/hamburger.svg alt=Menu></button> <a href="/" style=text-decoration:none><h1 class=logo>Web Applications Korea</h1></a><section class=app-bar-actions></section></div></header><nav class="navdrawer-container promote-layer"><h4>Navigation</h4><ul><li><a href=/aboutus.html>About us</a></li><li><a href=/articles.html>Articles</a></li></ul></nav><main><article class=post><blockquote><p>Polymer 0.8 Primer 의 요약본으로 앞으로 릴리즈될 Polymer 0.8 에 대해서 간단히 알 수 있도록 만들어졌습니다. 아래 내용은 2015 년 3 월 경에 작성되었으며 원본의 내용은 언제든지 변경될 수 있음을 알려드립니다.이 문서는 이해 후 중요하다고 판단되는 부분을 요약한 문서이며 최신 문서에 대한 정보는 해당 문서의 <a href=https://github.com/Polymer/polymer/blob/0.8-preview/PRIMER.md>원본문서</a> 를 참고하세요. 오역이나 수정사항은 <a href=https://github.com/wakrorg/wakr.org/issues>github</a> 를 통해서 해주세요.</p></blockquote><h2 id=bare-minum-custom-element-sugaring>Bare-minum Custom Element sugaring</h2><h3 id=custom-element-constructor>Custom Element Constructor</h3><p><code>Polymer.Class({...})</code> 을 사용하여 Custom Element 를 정의 할 수 있으며 이후 <code>document.registerElement()</code> 를 사용하여 등록가능합니다. 정의시에 <code>is</code> property 에 넘겨지는 HTML tag name 을 필요로 합니다. 아래 코드를 참고하세요</p><pre><code>var MyElement = Polymer.Class({
  is: 'my-element',

  // Custom element 의 lifecycle 이벤트
  created: function() {
    this.innerHTML = 'My element!';
  }
});

document.registerElement('my-element', MyElement);

// 위와 동등한 코드입니다.
var el1 = new MyElement();
var el2 = document.createElement('my-element');
</code></pre><h3 id=custom-element-registration>Custom Element Registration</h3><p>대부분의 경우 Polymer 에 의해 만들어진 Custom element prototype 을 바로 등록하기 원하기 때문에 <code>Polymer.Class</code> 와 <code>document.registerElement</code> 의 Wrapping 함수인 <code>Polymer({ ... })</code> 를 제공합니다.</p><pre><code>MyElement = Polymer({

  is: 'my-element',

  // See below for lifecycle callbacks
  created: function() {
    this.innerHTML = 'My element!';
  }

});

var el1 = new MyElement();
var el2 = document.createElement('my-element');
</code></pre><h3 id=bespoke-constructor-support>Bespoke constructor support</h3><p>Polymer 에서는 Custom element 인스턴스를 만들때 arguments 를 넘길 수 있도록 constructor 를 만들 수 있도록 지원하고 있습니다. document.createElement 를 사용하여 인스턴스 생성시 Polymer 가 먼저 리턴되고 사용자가 정의한 constructor 가 호출됩니다.</p><pre><code>MyElement = Polymer({

  is: 'my-element',

  constructor: function(foo, bar) {
    el.foo = foo;
    el.configureWithBar(bar);
  },

  configureWithBar: function(bar) {
    ...
  }

});

var el = new MyElement(42, 'octopus');
</code></pre><h3 id=native-html-element-extension>Native HTML element extension</h3><p>Polymer 에서는 Custom Element 표준에서 정의된 lifecycle callback 을 처리할 수 있도록 로우-레벨 api 를 대신 사용하도록, 표준에 정의된 이벤트 이름보다 짧은(shorter-named) 이름으로 lifecycle methods 를 제공하고 있습니다.</p><ul><li><code>created</code> 는 <code>createdCallback</code> 을 대신합니다.</li><li><code>attached</code> 는 <code>attachedCallback</code> 을 대신합니다.</li><li><code>detached</code> 는 <code>detachedCallback</code> 을 대신합니다.</li><li><code>attributeChanged</code> 는 <code>attributeChangedCallback</code> 을 대신합니다.</li></ul><p>다음 예제를 참고하세요</p><pre><code>MyElement = Polymer({

  is: 'my-element',

  created: function() {
    console.log(this.localName + '#' + this.id + ' was created');
  },
  attached: function() {
    console.log(this.localName + '#' + this.id + ' was attached');
  },
  detached: function() {
    console.log(this.localName + '#' + this.id + ' was detached');
  },
  attributeChanged: function(name, type) {
    console.log(this.localName + '#' + this.id + ' attribute ' + name +
      ' was changed to ' + this.getAttribute(name));
  }
});
</code></pre><h3 id=configuring-properties>Configuring properties</h3><p>object-valued 로 정의된 <code>properties</code> 는 Custom Element 의 properties 에 정의되어 그 자체적으로는 별다른 기능을 하지 않지만 property 와 property 에 정의된 filed 값은 다른 Polymer 기능에서 사용됩니다. 아래 예제에서 <code>count</code> 를 살펴보세요.</p><pre><code>Polymer({

  is: 'x-custom',

  properties: {
    user: String,
    isHappy: Boolean,
    count: {
      type: Number,
      readOnly: true,
      notify: true
    }
  },

  ready: function() {
    this.innerHTML = 'Hello World, I am a &lt;b&gt;Custom Element!&lt;/b&gt;';
  }
});
</code></pre><h3 id=attribute-deserialization>Attribute deserialization</h3><p><code>properties</code> 의 <code>property</code> 에 설정된 <code>type</code> 에 설정된 타입값으로 attribute 의 값이 전달됩니다. 특별히 설정되지 않으면 <code>value</code> 값에 따라 정의됩니다. 아래 예제에서 manager 의 경우 Boolean 값으로 설정되어 있어서 element 인스턴스에 어떠한 값이 (예를 들어 문자열) 이 설정되더라도 Boolean 값으로 전달됩니다.</p><pre><code>&lt;script&gt;

  Polymer({

    is: 'x-custom',

    properties: {
      user: String,
      manager: {
        type: Boolean,
        notify: true
      }
    },

    attached: function() {
      // render
      this.innerHTML = 'Hello World, my user is ' + (this.user || 'nobody') + '.\n' +
        'This user is ' + (this.manager ? '' : 'not') + ' a manager.';
    }

  });

&lt;/script&gt;

&lt;x-custom user="Scott" manager&gt;&lt;/x-custom&gt;
&lt;!--
&lt;x-custom&gt;'s innerHTML becomes:
Hello World, my user is Scott.
This user is a manager.
--&gt;
</code></pre><p>또한 dash-case attribute 이름은 camel-case properties 로 사용할 수 있습니다.</p><pre><code>&lt;script&gt;

  Polymer({

    is: 'x-custom',

    properties: {
      userName: String,
    }

  });

&lt;/script&gt;

&lt;x-custom user-name="Scott"&gt;&lt;/x-custom&gt;
&lt;!-- Sets &lt;x-custom&gt;.userName = 'Scott';  --&gt;
</code></pre><h3 id=static-attributes-on-host>Static attributes on host</h3><p>Custom element 에서 생성시간(create-time) 시에 <code>hostAttributes</code> 를 이용해서 prototype 에 name-value 를 할당할 수 있습니다. 기본적으로 HTML attribute 는 문자열을 사용해야합니다만 attribute serialize 를 이용해서 value 를 문자열로 변환하여 전달합니다. 이 예제에 사용된 true, 0 의 값은</p><pre><code>&lt;script&gt;

  Polymer({

    is: 'x-custom',

    hostAttributes: {
      role: 'button',
      'aria-disabled': true
      tabindex: 0
    }

  });

&lt;/script&gt;
</code></pre><p>이후 aria-disabled, “0” 로 변환되어 사용됩니다.</p><pre><code>&lt;x-custom role="button" aria-disabled tabindex="0"&gt;&lt;/x-custom&gt;
</code></pre><h3 id=prototype-mixins>Prototype mixins</h3><p>Polymer 에서는 <code>mixins</code> property 에 정의된 배열을 통해서 <code>mixin</code> 오브젝트를 만들 수 있습니다. <code>mixnins</code> 에 있는 재사용가능한 오브젝트에서 properties 를 가져와서 새로 정의한 Polymer element 간단히 에서 사용할 수 있습니다.</p><p>fun-mixin.html 는 두개의 메쏘드를 제공합니다.</p><pre><code>FunMixin = {

    funCreatedCallback: function() {
      this.makeElementFun();
    },

    makeElementFun: function() {
      this.style.border = 'border: 20px dotted fuchsia;';
    }
  };

});
</code></pre><p>my-element 는 fun-mixin.html 을 import 하여 자신의 prototype 에 위 두개의 메쏘드를 추가해서 사용할 수 있도록 <code>mixins</code> 를 이용합니다.</p><pre><code>&lt;link rel="import" href="fun-mixin.html"&gt;

&lt;script&gt;
  Polymer({

    is: 'my-element',

    mixins: [FunMixin],

    created: function() {
      this.funCreatedCallback();
    }

  });
&lt;/script&gt;
</code></pre><h2 id=template-stamping-and-tree-lifecycle>Template stamping and tree lifecycle</h2><h3 id=template-stamping-into-local-dom>Template stamping into local DOM</h3><p><code>local DOM</code> 은 자신의 element 의 생성과 매니징을 담당하고 있으며 element 의 childen 인 <code>light DOM</code> 과는 구분됩니다. Shadow DOM 지원여부에 따라, Native 또는 Shady DOM 시스템이 사용되는데 <code>local DOM</code> 이 실제로 shadow root 가지거나 개념적으로 생성되어 Polymer 에서 제어됩니다. Polymer 에서는 사용자가 <code>local DOM</code> 인지 <code>light DOM</code> 내부인지 인식할 필요없이 동일한 방법으로 접근할 수 있도록 common API 를 제공합니다.<br>&lt;<br>Polymer 에서는 <code>local DOM</code> 내에 정의된 template 를 이용하여 <code>local DOM</code> 의 elements 내에 element 를 찍어낼(stamping) 수 있습니다. 예제를 참고하면 <code>local DOM</code> 은 <code>&lt;dom-module&gt;</code> element 를 사용해서 정의하고 <code>id</code> attribute 를 사용하여 매치한후 <code>&lt;dom-module&gt;</code> element 내의 <code>&lt;template&gt;</code> 를 이용해서 구성된 element 들을 <code>local DOM</code> 내에 출력할 수 있습니다</p><pre><code>&lt;dom-module id="x-foo"&gt;
  &lt;template&gt;I am x-foo!&lt;/template&gt;
&lt;/dom-module&gt;

&lt;script&gt;
  Polymer({
    is: 'x-foo'
  });
&lt;/script&gt;
</code></pre><p>Polymer element 정의는 <code>Polymer({...})</code> 와 같은 코드로 할 수 있는 부분과 <code>&lt;dom-module&gt;</code> element 를 선언하는 두가지 부분으로 나눌 수 있습니다. 이 두 부분을 하나의 파일에 또는 다른 파일에 분리해서 사용할 수 있습니다.</p><h3 id=scoped-styling>Scoped styling</h3><p>Polymer 0.8 에서는 “<a href="http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom-201/">Shadow DOM styling rules</a>” 를 사용하여 element 의 <code>local DOM</code> 내부의 styling 을 합니다. <code>&lt;dom-module&gt;</code> 안에 정의된 <code>&lt;style&gt;</code> 를 통해서 이용할 수 있으며 <code>&lt;template&gt;</code> 내부에 <code>&lt;style&gt;</code> 을 정의하는 방식과는 조금 다릅니다.</p><pre><code>&lt;dom-module id="my-element"&gt;

  &lt;style&gt;
    :host {
      display: block;
      border: 1px solid red;
    }
    #child-element {
      background: yellow;
    }
    /* styling elements distributed to content (via ::content) requires */
    /* using a wrapper element for compatibility with shady DOM         */
    .content-wrapper &gt; ::content .special {
      background: orange;
    }
  &lt;/style&gt;

  &lt;template&gt;
    &lt;div id="child-element"&gt;In local Dom!&lt;/div&gt;
    &lt;div class="content-wrapper"&gt;&lt;content&gt;&lt;/content&gt;&lt;/div&gt;
  &lt;/template&gt;

&lt;/dom-module&gt;

&lt;script&gt;

    Polymer({
        is: 'my-element'
    });

&lt;/script&gt;
</code></pre><p>외부 stylesheets 를 로팅하는 방식은 현재 <a href=https://github.com/Polymer/polymer/blob/0.8-preview/PRIMER.md#external-stylesheets>실험적 기능</a> 을 통해서 제공됩니다.</p><h3 id=dom-re-distribution>DOM (re-)distribution</h3><p><code>local DOM</code> 에서 <code>light DOM</code> 을 같이 구성하기 위해서 Polymer 에서는 <code>&lt;content&gt;</code> element 를 지원합니다. <code>&lt;content&gt;</code> element 내에 정의된 <code>light DOM</code> 은 자신을 포함하는 <code>local DOM</code> 과 결합됩니다. <code>&lt;content&gt;</code> element 의 <code>select</code> attribute 와 간단한 selector 를 이용해서 가져올 node 들을 필터할 수 있습니다.</p><pre><code>&lt;template&gt;
  &lt;header&gt;Local dom header followed by distributed dom.&lt;/header&gt;
  &lt;content select=".content"&gt;&lt;/content&gt;
  &lt;footer&gt;Footer after distributed dom.&lt;/footer&gt;
&lt;/template&gt;
</code></pre><h3 id=dom-api>DOM API</h3><p>DOM API 를 바로 사용하는 대신에 Polymer 에서 제공하는 DOM API 를 통해서 <code>local DOM</code> 과 <code>light DOM</code> 을 적절히 관리할 수 있습니다. 아래는 제공되는 API 입니다.</p><ul><li>Polymer.dom(parent).appendChild(node)</li><li>Polymer.dom(parent).insertBefore(node, beforeNode)</li><li>Polymer.dom(parent).removeChild(node)</li><li>Polymer.dom(parent).querySelector(selector)</li><li>Polymer.dom(parent).querySelectorAll(selector)</li><li>Polymer.dom(parent).childNodes</li><li>Polymer.dom(node).parentNode</li><li>Polymer.dom(contentElement).getDistributedNodes()</li><li>Polymer.dom(node).getDestinationInsertionPoints()</li><li>Polymer.dom.flush()</li></ul><p>Polymer element 의 현재 <code>this</code> 를 사용하면 <code>light DOM</code> 체 추가/사입이 가능하고 <code>this.root</code> 를 사용하면 shadow root 에 삽입/추가 가 가능합니다.</p><pre><code>var toLight = document.createElement('div');
Polymer.dom(this).appendChild(toLight);

var toLocal = document.createElement('div');
var beforeNode = Polymer.dom(this.root).childNodes[0];
Polymer.dom(this.root).insertBefore(toLocal, beforeNode);

var allSpans = Polymer.dom(this).querySelectorAll('span');
</code></pre><p><code>Polymer.dom</code>은 반드시 <code>local DOM</code> 뿐만 아니라 어떤 노드에도 사용가능합니다.</p><pre><code>&lt;template&gt;
  &lt;div id="container"&gt;
     &lt;div id="first"&gt;&lt;/div&gt;
     &lt;content&gt;&lt;/content&gt;
  &lt;/div&gt;
&lt;/template&gt;

...

var insert = document.createElement('div');
Polymer.dom(this.$.container).insertBefore(insert, this.$.first);
</code></pre><p><code>getDistributedNodes</code> 와 <code>getDestinationInsertionPoints</code> 는 <code>&lt;content&gt;</code> 에 추가된 elements 등에 접근할 때 사용할 수 있습니다. 아래 예제에서는 <code>getDistributedNodes</code> 얻은 노드의 첫번째 자식과 <code>distributed</code> 와 <code>&lt;content&gt;</code> 에 추가된 <code>div</code> 가 같은 것을 보여줍니다.</p><pre><code>&lt;x-foo&gt;
  &lt;div&gt;&lt;/div&gt;
&lt;/x-foo&gt;

// x-foo's template
&lt;template&gt;
  &lt;content&gt;&lt;/content&gt;
&lt;/template&gt;
var div = Polymer.dom(xFoo).querySelector('div');
var content = Polymer.dom(xFoo.root).querySelector('content');
var distributed = Polymer.dom(content).getDistributedNodes()[0];
var insertedTo = Polymer.dom(div).getDestinationInsertionPoints();

// the following should be true:
assert.equal(distributed, div);
assert.equal(insertedTo, content)
</code></pre><h3 id=configuring-default-property-values>Configuring default property values</h3><p><code>properties</code> 에서는 <code>value</code> field 를 사용해서 기본값을 지정가능합니다. primitive도 value 일 수도 function 의 리턴된 value 모두 사용가능합니다.</p><pre><code>Polymer({
  is: 'x-custom',

  properties: {

    mode: {
      type: String,
      value: 'auto'
    },

    data: {
      type: Object,
      notify: true,
      value: function() { return {}; }
    }

  }
});
</code></pre><h3 id=ready-callback>Ready callback</h3><p><code>ready</code> 메쏘드는 element 의 template 이 모두 stamping 이 되고 <code>local DOM</code> 의 설정(deserialize/serialize/default value)이 완료 되는 시점에 호출되는 lifecycle 에 관련된 메쏘드입니다.</p><pre><code>ready: function() {
  this.$.ajax.go();
}
</code></pre><h2 id=declarative-data-binding-event-handlers-and-property-effects>Declarative data binding, event handlers, and property effects</h2><h3 id=local-node-marshalling>Local node marshalling</h3><p>Polymer 는 로컬 <code>local DOM</code> 내에 stamped 된 node 의 정보를 가지고 있습니다. 자주 접근하는 경우 <code>id</code> 를 명시하면 <code>this.$</code> 에 <code>id</code> 를 사용하여 바로 접근할 수 있습니다.</p><pre><code>&lt;dom-module id="x-custom"&gt;
  &lt;template&gt;
    Hello World from &lt;span id="name"&gt;&lt;/span&gt;!
  &lt;/template&gt;
&lt;/dom-module&gt;

&lt;script&gt;
  Polymer({

    is: 'x-custom',

    created: function() {
      this.$.name.textContent = this.name;
    }

  });
&lt;/script&gt;
</code></pre><h3 id=event-listener-setup>Event listener setup</h3><p><code>listeners</code> property 를 사용하여 host element 에 event 와 event handler 함수의 이름으로 매핑하여 이벤트 처리를 할 수 있습니다.</p><pre><code>&lt;dom-module id="x-custom"&gt;
  &lt;template&gt;
    &lt;div&gt;I will respond&lt;/div&gt;
    &lt;div&gt;to a click on&lt;/div&gt;
    &lt;div&gt;any of my children!&lt;/div&gt;
  &lt;/template&gt;
&lt;/dom-module&gt;

&lt;script&gt;
  Polymer({
    is: 'x-custom',

    listeners: {
      'click': 'handleClick'
    },

    handleClick: function(e) {
      alert("Thank you for clicking");
    }
  });
&lt;/script&gt;
</code></pre><h3 id=annotated-event-listener-setup>Annotated event listener setup</h3><p><code>local DOM</code> 안에 children element 에 이벤트를 사용하기 위해서는 template 내에서 <code>on-&lt;event&gt;</code> annotation 을 사용하면 됩니다. 이벤트만을 위해서 <code>id</code> 를 사용하는 경우에 이 annotation 을 사용하면 됩니다.</p><pre><code>&lt;dom-module id="x-custom"&gt;
  &lt;template&gt;
    &lt;button on-click="handleClick"&gt;Kick Me&lt;/button&gt;
  &lt;/template&gt;
&lt;/dom-module&gt;

&lt;script&gt;
  Polymer({

    is: 'x-custom',

    handleClick: function() {
      alert('Ow!');
    }

  });
&lt;/script&gt;
</code></pre><h3 id=property-change-callbacks-observers>Property change callbacks (observers)</h3><p><code>properties</code> 는 <code>observer</code> field 를 이용해서 특정 property 의 값의 변화를 감지해서 등록된 event handler 에 new/old value 넘겨줍니다. 이전에 Observer.observe 나 dirty checking 을 통해서 변화를 감지하는 대신에 관심있는 <code>properties</code> 를 등록하는 방식을 사용합니다.</p><pre><code>Polymer({
  is: 'x-custom',
  properties: {
    disabled: {
      type: Boolean,
      observer: 'disabledChanged'
    },
    highlight: {
      observer: 'highlightChanged'
    }
  },

  disabledChanged: function(newValue, oldValue) {
    this.toggleClass('disabled', newValue);
    this.highlight = true;
  },

  highlightChanged: function() {
    this.classList.add('highlight');
    setTimeout(function() {
      this.classList.remove('highlight');
    }, 300);
  }
});
</code></pre><p>여러개의 <code>properties</code> 를 감시하는 경우 <code>observers</code> 를 사용합니다.</p><pre><code>Polymer({
  is: 'x-custom',

  properties: {
    preload: Boolean,
    src: String,
    size: String
  },

  observers: {
    'preload src size': 'updateImage'
  },

  updateImage: function(preload, src, size) {
    // ... do work using dependent values
  }
});
</code></pre><p>paths(sub-properties) 또한 <code>observers</code> 를 이용해서 변화를 감시할 수 있습니다. <code>observers</code> 에 문제가 되는 paths 값의 변경은 다른 element 와의 Polymer property binding 나 <code>setPathValue</code> 를 통해서 변경되어야 합니다.</p><pre><code>Polymer({
  is: 'x-custom',

  properties: {
    user: Object
  },

  observers: {
    'user.manager.*': 'userManagerChanged'
  },

  userManagerChanged: function(newValue, oldValue, path) {
    if (path) {
      // sub-property of user.manager changed
      console.log('manager ' + path.split('.').pop() + ' changed to ' + newValue);
    } else {
      // user.manager object itself changed
      console.log('new manager name is ' + newValue.name);
    }
  }
});
</code></pre><h3 id=annotated-property-binding>Annotated property binding</h3><h4 id=basic-property-binding>Basic property binding</h4><p>Custom element 의 <code>properties</code> 는 text content 나 <code>local DOM</code> element 의 properties 로 바인딩 될 수 있다. 아래 예제는 textContent 로 바인딩 되는 경우다</p><pre><code>&lt;dom-module id="user-view"&gt;
    &lt;template&gt;

      &lt;!-- Supported --&gt;
      First: &lt;span&gt;&lt;/span&gt;&lt;br&gt;
      Last: &lt;span&gt;&lt;/span&gt;

      &lt;!-- Not currently supported! --&gt;
      &lt;div&gt;First: &lt;/div&gt;
      &lt;div&gt;Last: &lt;/div&gt;

    &lt;/template&gt;
&lt;/dom-module&gt;

&lt;script&gt;

  Polymer({

    is: 'user-view',

    properties: {
      first: String,
      last: String
    }

  });

&lt;/script&gt;

&lt;user-view first="Samuel" last="Adams"&gt;&lt;/user-view&gt;
</code></pre><p>다음은 <code>local DOM</code> element 의 properties 에 바인딩 하는 방법이다. binding annotation 은 js property 에 있는 동일한 이름으로 사용되어야 한다. 아래 경우에는 object sub-properties 가 사용되었다.</p><pre><code>&lt;dom-module id="main-view"&gt;
  &lt;template&gt;
    &lt;user-view first="" last=""&gt;&lt;/user-view&gt;
  &lt;/template&gt;
&lt;/dom-module&gt;

&lt;script&gt;

  Polymer({

    is: 'main-view',

    properties: {
      user: Object
    }

  });

&lt;/script&gt;
</code></pre><p>dash-case attribute 이름 <code>first-name</code> 은 camel-case properties <code>firstName</code> 로 바인드하기 위해서 사용한다.</p><pre><code>&lt;user-view first-name=""&gt;&lt;/user-view&gt;
&lt;!-- will set &lt;user-view&gt;.firstName = this.managerName; --&gt;
</code></pre><h4 id=property-change-notification-and-two-way-binding>Property change notification and Two-way binding</h4><p>Polymer 는 element 들 간의 two-way binding 을 지원합니다. 추가되거나 변경된 데이터의 변경사항을 hosts 로 전달 가능합니다. <code>properties</code> 에서는 <code>notify</code> flag 를 true 로 하는 경우 <code>non-bubbling DOM event</code> 를 해당 변경사항에 관심있어 하는 host 에 전달합니다. 이벤트 이름은 <code>&lt;property&gt;-changed</code> 이며 해당 <code>value</code> 와 <code>event.detail</code> 이 new value 로 전달 됩니다.</p><p>hosts 를 향한, upwards(상향) one-way 를 위해서는 <code>curly-braces, </code> 를 사용해야합니다. 만약 <code>square-brace[[property]]</code> 를 사용하면 upward one-way binding 대신에 downward(하향) one-way 바인딩이 설정됩니다.</p><p>정리해서 two-way 바인딩을 사용하려면:</p><ul><li>host 는 curly-brace 를 사용해야 합니다. square-brace 를 사용하는 경우 <code>notify</code> 설정값과 상관없이 downward one-way binding 이 설정됩니다.</li><li>child (element) 의 해당 property 의 <code>notify</code> flag 는 <code>true</code> 로 설정되어야 합니다.</li><li>child (element) 의 해당 property 의 <code>readOnly</code> flag 는 <code>true</code> 로 설정되지 않아야 합니다. 만약 <code>notify:true, readOnly:true, </code> 조건이라면 upward one-way 바인딩이 설정됩니다.</li></ul><h5 id=example-1-two-way-binding>Example 1: Two-way binding</h5><pre><code>&lt;script&gt;

  Polymer({
    is: 'custom-element',
    properties: {
      prop: {
        type: String,
        notify: true
      }
    }
  });

&lt;/script&gt;
...

&lt;!-- `value` 의 변경은 child 의 `prop`로 값이 하향(downward) 전달됩니다. --&gt;
&lt;!-- `prop` 의 변경은 hosts 의 `value` 로 값이 상향(upward) 전달됩니다. --&gt;
&lt;custom-element prop=""&gt;&lt;/custom-element&gt;
</code></pre><h5 id=example-2-one-way-binding-downward>Example 2: One-way binding (downward)</h5><pre><code>&lt;script&gt;
  Polymer({
    is: 'custom-element',
    properties: {
      prop: {
        type: String,
        notify: true
      }
    }
  });
&lt;/script&gt;

...

&lt;!-- `value` 의 변경은 child 의 `prop`로 값이 하향(downward) 전달됩니다. --&gt;
&lt;!-- `prop` 의 변경은 square-bracket 의해서 값이 무시됩니다. --&gt;
&lt;custom-element prop="[[value]]"&gt;&lt;/custom-element&gt;
</code></pre><h5 id=example-3-one-way-binding-downward>Example 3: One-way binding (downward)</h5><pre><code>&lt;script&gt;

  Polymer({
    is: 'custom-element',
    properties: {
      prop: String    // no `notify:true`!
    }
  });

&lt;/script&gt;
...

&lt;!-- `value` 의 변경은 child 의 `prop`로 값이 하향(downward) 전달됩니다. --&gt;
&lt;!-- `prop` 의 변경은 notify:false 에 의해서 이벤트가 일어나지 않습니다 --&gt;
&lt;custom-element prop=""&gt;&lt;/custom-element&gt;
</code></pre><h5 id=example-4-one-way-binding-upward>Example 4: One-way binding (upward)</h5><pre><code>&lt;script&gt;
  Polymer({
    is: 'custom-element',
    properties: {
      prop: {
          type: String,
          notify: true,
          readOnly: true
        }
    }
  });
&lt;/script&gt;

...
&lt;!-- `value` 의 변경은 readOnly:true 의해서 무시됩니다.--&gt;
&lt;!-- `prop` 의 변경은 hosts 의 `value` 로 값이 상향(upward) 전달됩니다. --&gt;
&lt;custom-element prop=""&gt;&lt;/custom-element&gt;
</code></pre><h5 id=example-5-error--non-sensical-state>Example 5: Error / non-sensical state</h5><pre><code>&lt;script&gt;

  Polymer({
    is: 'custom-element',
    properties: {
      prop: {
          type: String,
          notify: true,
          readOnly: true
        }
    }
  });

&lt;/script&gt;

...
&lt;!-- `value` 의 변경은 readOnly:true 의해서 무시됩니다.--&gt;
&lt;!-- `prop` 의 변경은 square-bracket 의해서 값이 무시됩니다. --&gt;
&lt;custom-element prop="[[value]]"&gt;&lt;/custom-element&gt;
</code></pre><h4 id=binding-to-structured-data>Binding to structured data</h4><p>Object 에서 관심있는 paths(sub-properties) 를 binding annotation 를 통해서 Custom element 의 properties 와 two-way 바인딩이 될 수 있습니다.</p><pre><code>&lt;template&gt;
  &lt;div&gt;&lt;/div&gt;
  &lt;user-element user=""&gt;&lt;/user-element&gt;
&lt;/template&gt;
</code></pre><p>바인딩 하고자 하는 paths (object sub-properties) 는 Polymer <a href=https://github.com/Polymer/polymer/blob/0.8-preview/PRIMER.md#property-binding>property binding</a> 을 사용하거나 <code>setPathValue</code> API 를 통해서 값이 변경된 것을 값을 변경하는 element 에서 시스템에 알려주어야 합니다. 두 elements 에서 공유된 object 레퍼런스를 property 참고하고 있기 때문에 one-way binding 의 컨셉은 이 경우에는 사용하지 않습니다.</p><h4 id=path-change-notification>Path change notification</h4><p>paths 의 two-way data-binding 이나 observation 은 이전에 2-way property binding 에서 설명한 방법을 사용합니다. sub-property 를 위한 property 의 <code>type</code> flag 에 <code>Object</code> 로 설정하고 해당 path 의 값이 변경이 되면 object 의 변경된 path 를 가르키는 <code>deail.path</code> 를 전달하는 <code>&lt;&lt;property&gt;-changed</code> non-bubbling DOM 이벤트가 발생됩니다. object 에 바인딩이나 이벤트 핸들러를 등록하여 이벤트를 받은 element 들은 변경된 path 값에 따라 side effects 의 영향을 받을 수도 있습니다. 이벤트를 받은 element 들은 그 object 를 바인딩하고 있는 children 에게 알림을 전달하고 hosts 로 다시 새 이벤트를 전달합니다.</p><p>Custom element 의 property 로 사용되어 값이 변경되는 경우 시스템은 잘 동작하지만 코드에서 직접 수정을 가하는 경우에는 별도로 알림을 주어야 한다 (Object.observe, dirty checking 을 사용할 수있지만 퍼포먼스등의 이유로 사용을 피한다) <code>notifyPath</code> 와 <code>setPathValue</code> 가 있다.</p><pre><code>&lt;dom-module id="custom-element"&gt;
  &lt;template&gt;
    &lt;div&gt;&lt;/div&gt;
  &lt;/template&gt;
&lt;/dom-module&gt;

&lt;script&gt;
  Polymer({

    is: 'custom-element',

    reassignManager: function(newManager) {
      this.user.manager = newManager;
      // Notification required for binding to update!
      this.notifyPath('user.manager', this.user.manager);
    }

  });
&lt;/script&gt;
</code></pre><p>값을 변경하고 알림을 보내주 것을 한동작 으로 해주는 <code>setPathValue</code> 도 아래처럼 사용가능하다</p><pre><code>reassignManager: function(newManager) {
  this.setPathValue('user.manager', newManager);
}
</code></pre><h4 id=expressions-in-binding-annotations>Expressions in binding annotations</h4><p>현재는 부정을 우한 <code>!</code> expression 만 제공된다.</p><pre><code>&lt;template&gt;
  &lt;div hidden=""&gt;&lt;/div&gt;
&lt;/template&gt;
</code></pre><h3 id=declarative-attribute-binding>Declarative attribute binding</h3><p>Custom element 의 property 에 값을 할당해서 사용, 전하는 방법도 있지만 attribute 에 바로 값을 적용하는 방법도 필요합니다. <code>$=</code> binding annotation 을 통해서 attribute binding 을 제공합니다 Custom element property 를 사용한, <code>element.property = value;</code> 방식으로 attribute 에 값이 적용되는 것이 아니라 <code>element.setAttribute('&lt;attr&gt;', value);</code> 를 통한 결과로 값을 적용할 수 있습니다.로 각 값들은 타입에 맞게 Serialized 거쳐서 attribute 의 값으로(String, set/unset) 전달됩니다.</p><pre><code>&lt;template&gt;

  &lt;!-- Attribute binding --&gt;
  &lt;my-element selected$=""&gt;&lt;/my-element&gt;
  &lt;!-- results in &lt;my-element&gt;.setAttribute('selected', this.value); --&gt;

  &lt;!-- Property binding --&gt;
  &lt;my-element selected=""&gt;&lt;/my-element&gt;
  &lt;!-- results in &lt;my-element&gt;.selected = this.value; --&gt;

&lt;/template&gt;
</code></pre><h3 id=binding-to-native-element-attributes>Binding to native element attributes</h3><p>native element attributeu 역시 <code>$=</code> 를 사용하여 attribute binding 을 사용할 수 있습니다.</p><pre><code># 일반적인 정적 attribute 값 할당

&lt;!-- class --&gt;
&lt;div class="foo"&gt;&lt;/div&gt;

&lt;!-- style --&gt;
&lt;div style="background: red;"&gt;&lt;/div&gt;

&lt;!-- href --&gt;
&lt;a href="http://foo.com"&gt;

&lt;!-- label for --&gt;
&lt;label for="bar"&gt;&lt;/label&gt;

&lt;!-- dataset --&gt;
&lt;div data-bar="baz"&gt;&lt;/div&gt;

# 동적인 값을 가질 수 있는 Attribute binding (use $=):

&lt;!-- class --&gt;
&lt;div class$=""&gt;&lt;/div&gt;

&lt;!-- style --&gt;
&lt;div style$=""&gt;&lt;/div&gt;

&lt;!-- href --&gt;
&lt;a href$=""&gt;

&lt;!-- label for --&gt;
&lt;label for$=""&gt;&lt;/label&gt;

&lt;!-- dataset --&gt;
&lt;div data-bar$=""&gt;&lt;/div&gt;
</code></pre><h3 id=reflecting-properties-to-attributes>Reflecting properties to attributes</h3><p>attribute 의 값을 property 와 동기화 하고 싶은 경우 property 의 <code>reflectToAttribute: true</code> flag 를 사용하여 값을 동기화할 수 있습니다.</p><pre><code>&lt;script&gt;
  Polymer({

    properties: {
     response: {
        type: Object,
        reflectToAttribute: true
     }
    },

    responseHandler: function(response) {
      this.response = 'loaded';
      // results in this.setAttribute('response', 'loaded');
    }

  });
&lt;/script&gt;
</code></pre><h3 id=computed-properties>Computed properties</h3><p><code>properties</code> 의 다른 property 를 통해서 값을 새로 만들 수 있도록 <code>computed</code> 키에 <code>computing function</code> 을 매핑할 수 있습니다. 의존되는 properties 를 괄호안에 arguments 로 제공되어야 하고 의존하고 있는 property 의 값이 바뀌면 호출됩니다. (asynchronously)</p><pre><code>&lt;dom-module id="x-custom"&gt;
  &lt;template&gt;
    My name is &lt;span&gt;&lt;/span&gt;
  &lt;/template&gt;
&lt;dom-module id="x-custom"&gt;

&lt;script&gt;
  Polymer({

    is: 'x-custom',

    properties: {

      first: String,

      last: String,

      fullName: {
        type: String,
        // `first` 또는 `last` 이 변경되면 `computeFullName` 이 한번 호출되고 
        // (asynchronously) 리턴된 값은 `fullName` 에 저장된다
        computed: 'computeFullName(first, last)'
      } 

    },

    computeFullName: function(first, last) {
      return first + ' ' + last;
    }
    ...
  });
&lt;/script&gt;
</code></pre><h3 id=annotated-computed-properties>Annotated computed properties</h3><p><code>Anonymous computed properties</code> 는 template 내에 binding annotation 으로 사용가능하다. 리턴되는 값이 property 로 저장될 필요 없는 경우 유용하다.</p><pre><code>&lt;dom-module id="x-custom"&gt;
  &lt;template&gt;
    My name is &lt;span&gt;&lt;/span&gt;
  &lt;/template&gt;
&lt;dom-module id="x-custom"&gt;

&lt;script&gt;
  Polymer({

    is: 'x-custom',

    properties: {

      first: String,

      last: String

    },

    computeFullName: function(first, last) {
      return first + ' ' + last;
    }

    ...

  });
&lt;/script&gt;
</code></pre><h3 id=read-only-properties>Read-only properties</h3><p>데이터가 참조만 되는 경우 <code>readOnly:true</code> 를 통해서 우연한 데이터 변경을 방지 할 수 있습니다. 실제값의 변경은 <code>_set&lt;Property&gt;(value).</code> 을 통해서 가능하고 일반적으로 <code>notify:true</code> 를 사용합니다.</p><pre><code>&lt;script&gt;
  Polymer({

    properties: {
      response: {
        type: Object,
        readOnly: true,
        notify: true
      }
    },

    responseHandler: function(response) {
      this._setResponse(response);
    }
  });
&lt;/script&gt;
</code></pre><h3 id=utility-functions>Utility Functions</h3><p>Polymer’s Base prototype 아래의 편하고/유용한 함수를 제공합니다. 자세한 것은 API 문서를 참고하세요</p><ul><li>toggleClass: function(name, bool, [node])</li><li>toggleAttribute: function(name, bool, [node])</li><li>attributeFollows: function(name, neo, old)</li><li>fire: function(type, [detail], [onNode], [bubbles], [cancelable])</li><li>async: function(method)</li><li>transform: function(node, transform)</li><li>translate3d: function(node, x, y, z)</li><li>importHref: function(href, onload, onerror)</li></ul><h3 id=global-polymer-settings>Global Polymer settings</h3><p>Document-level 에서 Polymer 의 셋팅이 가능합니다. 메인 다큐먼트의 처음에 위치해서 사용합니다.</p><pre><code>&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;script&gt; Polymer = { dom: 'shadow' }; &lt;/script&gt;
  &lt;script src="../../../webcomponentsjs/webcomponents-lite.js"&gt;&lt;/script&gt;
  &lt;link rel="import" href="components/my-app.html"&gt;
&lt;/head&gt;
&lt;body&gt;
</code></pre><p>또한 query string 을 통해서 변경할 수 있습니다.</p><pre><code>http://myserver.com/test-app/index.html?dom=shadow
</code></pre><p>가능한 셋팅은 아래와 같습니다.</p><ul><li>dom - options:<ul><li>shady - 모든 <code>local DOM</code> 은 Shadow DOM 지원여부와 상관없이 <code>Shady DOM</code> 을 사용하여 렌더링합니다.</li><li>shadow - <code>local DOM</code> 은 Shadow DOM 을 사용하여 렌더링 됩니다. (곧 default 가 될 것입니다)</li></ul></li></ul><h2 id=experimental-features--elements>Experimental Features &amp; Elements</h2><blockquote><p>여기에 소개되는 기능들은 실험단계이며 언제든지 변경될 수 있습니다.</p></blockquote><h3 id=template-repeater-x-repeat>Template repeater (x-repeat)</h3><p>Array 가 binding 된 경우 각 아이템 만큼 template 를 DOM 안에 <code>x-repeat</code> element 에 stamping 한다. <code>items</code> property 를 통해서 Array 를 전달하고 <code>item</code> 으로 접근 가능하다.</p><pre><code>&lt;dom-module id="employee-list"&gt;

  &lt;template&gt;

    &lt;div&gt; Employee list: &lt;/div&gt;
    &lt;template is="x-repeat" items=""&gt;
        &lt;div&gt;First name: &lt;span&gt;&lt;/span&gt;&lt;/div&gt;
        &lt;div&gt;Last name: &lt;span&gt;&lt;/span&gt;&lt;/div&gt;
    &lt;/template&gt;

  &lt;/template&gt;

  &lt;script&gt;
    Polymer({
      is: 'employee-list',
      ready: function() {
        this.employees = [
            {first: 'Bob', last: 'Smith'},
            {first: 'Sally', last: 'Johnson'},
            ...
        ];
      }
    });
  &lt;/script&gt;

&lt;/dom-module&gt;
</code></pre><p><code>items</code> 의 sub-properties 변경 사항은 template instance 로 전달되고 업데이트 된다. Array.observe (또는 experimental shim API) 를 사용하고 template 안의 instance 와 Array 는 동기화 된다. 아래처럼 필터함수도 사용가능하다.</p><pre><code>isEngineer: function(item) {
    return item.type == 'engineer' || item.manager.type == 'engineer';
}
</code></pre><p>그런 다음 <code>observer</code> property 에 필터링 되는 sub-properties 를 같이 설정해준다.</p><pre><code>&lt;template is="x-repeat" items="" 
          filter="isEngineer" observe="type manager.type"&gt;
</code></pre><h3 id=array-selector-x-array-selector>Array selector (x-array-selector)</h3><p><code>x-array-selector</code> 를 사용하면 Polymer 가 제공하는 데이터 동기화를 자연스럽게 사용하면서 대상 Array 내에서 특정 item 을 선택해서 어플리케이션에서 다시 사용할 수 있습니다. <code>items</code> 할당된 사용자 데이터를 공유하면서 <code>select/deselect</code> 를 통해서 별도의 리스트로 이용가능합니다.</p><pre><code>&lt;dom-module id="employee-list"&gt;

  &lt;template&gt;

    &lt;div&gt; Employee list: &lt;/div&gt;
    &lt;template is="x-repeat" id="employeeList" items=""&gt;
        &lt;div&gt;First name: &lt;span&gt;&lt;/span&gt;&lt;/div&gt;
        &lt;div&gt;Last name: &lt;span&gt;&lt;/span&gt;&lt;/div&gt;
        // 전체 리스트에서 아이템 선택시 이벤트 발생
        &lt;button on-click="toggleSelection"&gt;Select&lt;/button&gt;
    &lt;/template&gt;

    &lt;x-array-selector id="selector" items="" selected="" multi toggle&gt;&lt;/x-array-selector&gt;

    &lt;div&gt; Selected employees: &lt;/div&gt;
    &lt;template is="x-repeat" items=""&gt;
        &lt;div&gt;First name: &lt;span&gt;&lt;/span&gt;&lt;/div&gt;
        &lt;div&gt;Last name: &lt;span&gt;&lt;/span&gt;&lt;/div&gt;
    &lt;/template&gt;

  &lt;/template&gt;

  &lt;script&gt;
    Polymer({
      is: 'employee-list',
      ready: function() {
        this.employees = [
            {first: 'Bob', last: 'Smith'},
            {first: 'Sally', last: 'Johnson'},
            ...
        ];
      },
      toggleSelection: function(e) {
        // #employeeList 가 가지고 있는 items 에서 item 을 쿼리
        var item = this.$.employeeList.itemForElement(e.target);
        // x-array-selector 에 select 요청하면 `selected` 는 업데이트되고
        // `Selected employees` 의 리스트는 업데이
        this.$.selector.select(item);
      }
    });
  &lt;/script&gt;

&lt;/dom-module&gt;
</code></pre><h3 id=auto-binding-template>Auto-binding template</h3><p>Polymer binding 기능은 Polymer elements 를 정의할 때 사용하는 template 에서만 사용가능했는데 <code>x-autobind</code> 을 사용하면 새로운 Custom element 정의 없이 바로 메인 다큐먼트에서 사용가능하다</p><pre><code>&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;script src="components/webcomponentsjs/webcomponents-lite.js"&gt;&lt;/script&gt;
  &lt;link rel="import" href="components/polymer/polymer.html"&gt;
  &lt;link rel="import" href="components/core-ajax/core-ajax.html"&gt;

&lt;/head&gt;
&lt;body&gt;

  &lt;!-- Wrap elements in with auto-binding template to --&gt;
  &lt;!-- allow use of Polymer bindings main document --&gt;
  &lt;template is="x-autobind"&gt;

    &lt;core-ajax url="http://..." lastresponse=""&gt;&lt;/core-ajax&gt;

    &lt;template is="x-repeat" items=""&gt;
        &lt;div&gt;&lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt;
    &lt;/template&gt;

  &lt;/template&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre><h3 id=cross-scope-styling>Cross-scope styling</h3><h4 id=background>Background</h4><p>기존의 Shadow DOMp서는 각 local DOM 의 style 이 <code>/deep/</code> 이나 <code>::shadow</code> 를 통해서 재정의 되지 않는한 각각의 독립적인 scope 는 보장되었습니다. 하지만 theming 위해서 style 을 공유하거나 변경하려면 <code>/deep/</code> 이나 <code>::shadow</code> 방법외에는 없고 이 방법은 많은 문제점이 있습니다. 따라서 이를 해결할 방법이 필요해졌습니다.</p><h4 id=custom-css-properties>Custom CSS properties</h4><p>Polymer 0.8 에서는 <code>Custom CSS properties</code> 를 위해서 매우 실험적이고 opt-in shim 형태로 제공합니다. 더 자세한 내용은 아래 자료 참고</p><ul><li><a href="http://dev.w3.org/csswg/css-variables/">W3C CSS Custom Properties for Cascading Variables specification</a> (<a href=https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_variables>MDN 설명</a>)</li></ul><p>내부의 상세 정보를 노출하는 것보다는 <code>CSS properties</code> 를 사용하여 element 를 구성하여 적용하는 것이 theming 하는 경우 더 좋습니다. 아래 예제에서 작성자는 <code>my-toolbar</code> 의 <code>title</code> 색을 바꾸기 위해서 <code>--my-toolbar-title-color</code> 라는 custom property 를 사용하여 CSS 규칙에 따라 <code>--my-toolbar-title-color</code> 를 <code>my-toolbar</code> 를 사용하는 상위에서 정의해서 적용할 수 있도록 했습니다.</p><pre><code>&lt;dom-module id="my-toolbar"&gt;

  &lt;style&gt;
    :host {
      padding: 4px;
      background-color: gray;
    }
    .title {
      color: var(--my-toolbar-title-color);
    }
  &lt;/style&gt;

  &lt;template&gt;
    &lt;span class="title"&gt;&lt;/span&gt;
  &lt;/template&gt;

  &lt;script&gt;
    Polymer({
      is: 'my-toolbar',
      properties: {
        title: String
      },
      // custom properties shim 은 opt-in 기능입니다 활성화를 해주어야 합니다.
      enableCustomStyleProperties: true
    });
  &lt;/script&gt;

&lt;/dom-module&gt;
</code></pre><p><code>my-toolbar</code> 를 사용하는 host 에서 정의한 <code>--my-toolbar-title-color</code> 의 값이 적용되는 예제입니다. 별다른 class 지정이 없으면 host 의 값이 적용되고 <code>class=warning</code> 을 명시하면 <code>.warning</code> 의 <code>--my-toolbar-title-color</code> 값이 적용됩니다.</p><pre><code>&lt;dom-module id="my-element"&gt;

  &lt;style&gt;

    /* Make all toolbar titles in this host green by default */
    :host {
      --my-toolbar-title-color: green;
    }

    /* Make only toolbars with the .warning class red */
    .warning {
      --my-toolbar-title-color: red;
    }

  &lt;/style&gt;

  &lt;template&gt;

    &lt;my-toolbar title="This one is green."&gt;&lt;/my-toolbar&gt;
    &lt;my-toolbar title="This one is green too."&gt;&lt;/my-toolbar&gt;

    &lt;my-toolbar class="warning" title="This one is red."&gt;&lt;/my-toolbar&gt;

  &lt;/template&gt;

&lt;/dom-module&gt;
</code></pre><p><code>--my-toolbar-title-color</code> 라는 custom property 의 값을 통해서 <code>my-toolbar</code> 의 내부 구현의 변경에 상관없이 타이틀의 색을 변경 할수 있습니다. 하지만 매번 각각의 CSS property 를 정의하기 보다는 Polymer 에서는 <code>var</code> 와 유사한 <code>mixin</code> 을 제공해서 한번에 여러가지 CSS property 를 적용할 수 있습니다.</p><pre><code>&lt;dom-module id="my-toolbar"&gt;

  &lt;style&gt;
    :host {
      padding: 4px;
      background-color: gray;
      mixin(--my-toolbar-theme);
    }
    .title {
      mixin(--my-stopwatch-title-theme);
    }
  &lt;/style&gt;

  &lt;template&gt;
    &lt;span class="title"&gt;&lt;/span&gt;
  &lt;/template&gt;

  ...

&lt;/dom-module&gt;
</code></pre><p>아래 예제는 <code>--my-toolbar-theme</code>, <code>--my-toolbar-title-theme</code> 에 여러가지 CSS Property 를 적용할 수 있는 것을 보여줍니다.</p><pre><code>&lt;dom-module id="my-element"&gt;

  &lt;style&gt;

    /* Apply custom theme to toolbars */
    :host {
      --my-toolbar-theme: {
        background-color: green;
        border-radius: 4px;
        border: 1px solid gray;
      }
      --my-toolbar-title-theme: {
        color: green;
      }
    }

    /* Make only toolbars with the .warning class red and bold */
    .warning {
      --my-toolbar-title-theme: {
        color: red;
        font-weight: bold;
      }
    }

  &lt;/style&gt;

  &lt;template&gt;

    &lt;my-toolbar title="This one is green."&gt;&lt;/my-toolbar&gt;
    &lt;my-toolbar title="This one is green too."&gt;&lt;/my-toolbar&gt;

    &lt;my-toolbar class="warning" title="This one is red."&gt;&lt;/my-toolbar&gt;

  &lt;/template&gt;

&lt;/dom-module&gt;
</code></pre><h4 id=custom-properties-shim---limitations-and-api-details>Custom Properties Shim - Limitations and API details</h4><p>여러가지 이유로 현재 Custom CSS properties 는 아래와 같은 제약이 있습니다.</p><ul><li>이 기능은 여전히 experimental 입니다. element 에 기본적으로 적용되지 않으며 <code>enableCustomStyleProperties: true</code> 을 설정해서 사용해 합니다.</li><li>Custom properties 는 생성시에 매치되어 적용됩니다. 동적 업데이트는 지원하지 않습니다.</li><li><code>this.updateStyles()</code> 호출하더라도 style 은 적용되지 않습니다.</li><li><p>아래 첫번째 예제 처럼 <code>var</code> 가 가지는 property 변경을 통해서 style 변경하려는 경우에도 적용되지 않습니다.</p><pre><code>#title {
  background-color: var(--title-background-normal);
}
#title.highlighted {
  background-color: var(--title-background-highlighted);
}
</code></pre><p>하지만 이렇게 <code>.highlighted</code> class 를 추가/제거해서 ` –title-background` 값을 변경하는 형태로 사용하면 적용됩니다.</p><pre><code>#title {
  --title-background: gray;
}

#title.highlighted {
  --title-background: yellow;
}
</code></pre></li></ul><h3 id=custom-element-for-document-styling-x-style>Custom element for document styling (x-style)</h3><p>메인 다큐먼트에서 Polymer 의 styling 시스템의 기능을 사용할 수 있습니다.</p><pre><code>&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;script src="components/webcomponentsjs/webcomponents-lite.js"&gt;&lt;/script&gt;
  &lt;link rel="import" href="components/polymer/polymer.html"&gt;

  &lt;style is="x-style"&gt;

    /* Polymer elements 의 local DOM 으로 적용되지 않습니다.  */
    * {
      box-sizing: border-box;
    }

    /* /deep/ and ::shadow combinators 사용가능 */
    body /deep/ .my-special-view::shadow #thing-inside {
      background: yellow;
    }

    /* Custom properties 사용가 */
    * {
      --my-toolbar-title-color: green;
    }

  &lt;/style&gt;

&lt;/head&gt;
&lt;body&gt;

    ...

&lt;/body&gt;
&lt;/html&gt;
</code></pre><h3 id=external-stylesheets>External stylesheets</h3><p>HTML Imports 의 장점을 살려서 외부 CSS 를 로딩해서 <code>local DOM</code> 의 element 에 적용할 수 있습니다. 따라서 CSS 를 공유할수도 있습니다.</p><pre><code>&lt;dom-module id="my-awesome-button"&gt;

  &lt;!-- special import with type=css used to load remote CSS --&gt;
  &lt;link rel="import" type="css" href="my-awesome-button.css"&gt;

  &lt;template&gt;
    ...
  &lt;/template&gt;

  &lt;script&gt;
    Polymer({
      is: 'my-awesome-button',
      ...
    });
  &lt;/script&gt;

&lt;/dom-module&gt;
</code></pre><h3 id=feature-layering>Feature layering</h3><p>Polymer 0.8 은 현재 기능별로 3 개의 레이어를 제공하며 3 개 별개로 HTML Imports 가능합니다.</p><ul><li>polymer-micro.html: Polymer micro features (bare-minum Custom Element sugaring)</li><li>polymer-mini.html: Polymer mini features (template stamped into “local DOM” and tree lifecycle)</li><li>polymer.html: Polymer standard features (all other features: declarative data binding and event handlers, property nofication, computed properties, and experimental features)</li></ul><h2 id=migration-notes>Migration Notes</h2><p>자세한 내용은 <a href=https://github.com/Polymer/polymer/blob/0.8-preview/PRIMER.md#migration-notes>원문</a>을 참고하세요.</p></article><script>
  (function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
  function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
  e=o.createElement(i);r=o.getElementsByTagName(i)[0];
  e.src='//www.google-analytics.com/analytics.js';
  r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
  ga('create','UA-53779719-1');ga('send','pageview');
</script><footer><section class="home feeds"><p>The content of this page is licensed under the <a rel=license href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0 License</a>, and code samples are licensed under the <a rel=license href=http://opensource.org/licenses/MIT>MIT License</a>. ©2013 <a href=http://github.com/wakrorg>wakr.org</a></p></section></footer></main><script src=/scripts/main.min.js></script></body></html>